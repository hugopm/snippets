snippet ordset
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;

typedef tree<long long, null_type, less<long long>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
// find_by_order (0-indexed), order_of_key (number of elements strictly smaller)

endsnippet

snippet ght
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;

struct custom_hash {
	static uint64_t splitmix64(uint64_t x) {
		// http://xorshift.di.unimi.it/splitmix64.c
		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};

using ght = gp_hash_table<long long, long long, custom_hash>;

endsnippet

snippet ss2
struct $1 {
	int $2, $3;
	bool operator<(const $1 &oth) const {
		if ($2 != oth.$2) return $2 < oth.$2;
		else return $3 < oth.$3;
	}
};

$0
endsnippet

snippet ss3
struct $1 {
	int $2, $3, $4;
	bool operator<(const $1 &oth) const {
		if ($2 != oth.$2) return $2 < oth.$2;
		else if ($3 != oth.$3) return $3 < oth.$3;
		else return $4 < oth.$4;
	}
};

$0
endsnippet

snippet ss4
struct $1 {
	int $2, $3, $4, $5;
	bool operator<(const $1 &oth) const {
		if ($2 != oth.$2) return $2 < oth.$2;
		else if ($3 != oth.$3) return $3 < oth.$3;
		else if ($4 != oth.$4) return $4 < oth.$4;
		else return $5 < oth.$5;
	}
};

$0
endsnippet

snippet rng
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
endsnippet

snippet sieve
const int limSieve = $1;
int sieve[limSieve];

void initSieve() {
	for (int x = 2; x < limSieve; ++x) {
		if (sieve[x] == 0) {
			sieve[x] = x;
			for (int c = 2; c*x < limSieve; ++c) {
				if (sieve[c*x] == 0)
					sieve[c*x] = x;
			}
		}
	}
}

vector<pair<int, int>> factorize(int x) {
	vector<pair<int, int>> dcp;
	while (x > 1) {
		if (dcp.empty() || dcp.back().first != sieve[x]) {
			dcp.emplace_back(sieve[x], 0);
		}
		++dcp.back().second;
		x /= sieve[x];
	}
	return dcp;
}
endsnippet

snippet for
for (int ${1:i} = 0; $1 < ${2:n}; ++$1) {
	$0
}
endsnippet

snippet for1
for (int ${1:i} = 1; $1 <= ${2:n}; ++$1) {
	$0
}
endsnippet

snippet ford
for (int ${1:i} = ${2:n}-1; $1 >= 0; --$1) {
	$0	
}
endsnippet

snippet max
${1:x} = max($1, ${2:v});$0
endsnippet

snippet min
${1:x} = min($1, ${2:v});$0
endsnippet

snippet all "" i
${1:vec}.begin(), $1.end()$0
endsnippet

snippet rall "" i
${1:vec}.rbegin(), $1.rend()$0
endsnippet

snippet sort
sort(${1:vec}.begin(), $1.end());$0
endsnippet

snippet rsort
sort(${1:vec}.rbegin(), $1.rend());$0
endsnippet

snippet rs1 "n, vector"
int ${1:n};
cin >> $1;
vector<int> ${2:vec}($1);
for (int i = 0; i < $1; ++i) {
	cin >> $2[i];
}
$0
endsnippet

snippet rs2 "n,k,vector"
int ${1:n}, ${2:k};
cin >> $1 >> $2;
vector<int> ${3:vec}($1);
for (int i = 0; i < $1; ++i) {
	cin >> $3[i];
}
$0
endsnippet

snippet multivec
template<int D, typename T>
struct Vec : public vector<Vec<D - 1, T>> {
  static_assert(D >= 1, "Vector dimension must be greater than zero!");
  template<typename... Args>
  Vec(int n = 0, Args... args) : vector<Vec<D - 1, T>>(n, Vec<D - 1, T>(args...)) {
  }
};
template<typename T>
struct Vec<1, T> : public vector<T> {
  Vec(int n = 0, const T& val = T()) : vector<T>(n, val) {
  }
};
endsnippet

snippet acc "long long"
accumulate(${1:vec}.begin(), $1.end(), 0LL)
endsnippet

snippet r1
int $1;
cin >> $1;
endsnippet

snippet r2
int $1, $2;
cin >> $1 >> $2;
endsnippet

snippet r3
int $1, $2, $3;
cin >> $1 >> $2 >> $3;
endsnippet

snippet r4
int $1, $2, $3, $4;
cin >> $1 >> $2 >> $3 >> $4;
endsnippet

snippet r1n
int $1;
cin >> $1;
--$1;
endsnippet

snippet r2n
int $1, $2;
cin >> $1 >> $2;
--$1; --$2;
endsnippet

snippet r3n
int $1, $2, $3;
cin >> $1 >> $2 >> $3;
--$1; --$2; --$3;
endsnippet

snippet r4n
int $1, $2, $3, $4;
cin >> $1 >> $2 >> $3 >> $4;
--$1; --$2; --$3; --$4;
endsnippet

snippet grid
for (int lig = 0; lig < nbLig; ++lig) {
	for (int col = 0; col < nbCol; ++col) {
		$0
	}
}
endsnippet

snippet forl
for (int i$1 = 0; i$1 < nb$1; ++i$1) {
	$0
}
endsnippet

global !p
def convert(name):
	return name.capitalize()
endglobal

snippet foro
for (int ${1:node} = 0; $1 < nb`!p snip.rv = convert(t[1])`; ++$1) {
	$0
}
endsnippet
